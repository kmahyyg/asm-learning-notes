# 5.7 模块化程序设计

## Preview

在我们开始之前，我们已经在前面几节中学习过数据与地址的定位与处理方法和基本的子程序实现的思路。请确保在继续之前你已完成之前的学习并相对有了一定的经验。

## 模块化程序的必要性

设计多个相互联系、功能独立的问题有助于我们将大型的问题分解成一个又一个的小问题，便于我们解决。这些子程序还可以在未来被其他程序复用，同时在主程序框架实现较好的扩展性。以高级语言中的 C 语言为例，我们完全可以将一些个人经常使用的自定义函数打包成一个头文件

## 参数和结果传递的问题

根据具体问题具体分析，主要考虑传入参数的处理和运算结果的保存位置问题。对于编写代码过程中，应当写有详细注释。

个人建议注释应当包含：作者信息、授权信息、函数的功能参数和结果的说明，对于开源项目尤甚。

在编写的过程中需要注意寄存器的搭配使用，对于一些寻址过程中要求搭配使用的寄存器，切勿混用。我们建议当出现需要存放单一数据时，优先使用可以使用的寄存器。

字符(串)操作的过程中需要注意清楚 是 `word ptr` 还是 `byte ptr`。

## 批量数据的传递问题

使用一段内存存储大量数据，使用 DS、ES 配合 SI、DI 传递参数。

也可以使用栈传递数据，具体请参考 附注 4  [使用栈传递参数](ramndata/ref_tb4.md)

## 寄存器冲突

一个常见的问题是 `loop` 指令所需要用到的 CX 寄存器冲突问题，之前，我们已经在 [实验五](https://asm.kmahyyg.xyz/exps/exp5-doubleloop.html#%E5%AE%9E%E9%AA%8C%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90) 中介绍过一些方法。

整体来说，这类问题乍眼看来，有两个解决思路：
 - 尽可能不使用会产生冲突的存储器。
 - 注意在写程序时避免类似情况，并暂时调用其它寄存器来存储。

但是，以上的两个思路要么会造成大量的人力浪费，要么会造成后续维护或大量子程序的编写困难。

这也就告诉我们，也就只剩下了一条路，使用栈段暂存对应的暂存器数据，并在对应场景恢复对应状态数据。务必注意出栈和入栈的顺序。